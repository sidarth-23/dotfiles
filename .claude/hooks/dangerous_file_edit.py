#!/usr/bin/env python3
"""
Dangerous File Edit Hook - Blocks modifications to auto-generated and lock files
Supports: Python, Go, JavaScript/TypeScript, Rust, C++
"""
import sys
import json
import os
import re

# Files that should never be manually edited, grouped by ecosystem
DANGEROUS_FILES = {
    # JavaScript/TypeScript
    "js": {
        "lock_files": [
            "pnpm-lock.yaml",
            "package-lock.json",
            "yarn.lock",
            "bun.lockb",
            "npm-shrinkwrap.json",
        ],
        "generated": [
            ".next/",
            ".nuxt/",
            "dist/",
            "build/",
            ".output/",
            ".vercel/",
            ".netlify/",
            "node_modules/",
            ".pnp.cjs",
            ".pnp.loader.mjs",
            ".yarn/cache/",
            ".yarn/unplugged/",
            ".yarn/install-state.gz",
            "*.tsbuildinfo",
            ".docusaurus/",
            ".cache/",
        ],
        "config_generated": [
            ".eslintcache",
            ".stylelintcache",
        ],
    },

    # Python
    "python": {
        "lock_files": [
            "poetry.lock",
            "Pipfile.lock",
            "pdm.lock",
            "uv.lock",
            "requirements.lock",
        ],
        "generated": [
            "__pycache__/",
            "*.pyc",
            "*.pyo",
            "*.pyd",
            ".Python",
            "*.so",
            "*.egg-info/",
            "*.egg",
            "dist/",
            "build/",
            "eggs/",
            ".eggs/",
            "sdist/",
            "wheels/",
            ".installed.cfg",
            "MANIFEST",
            ".mypy_cache/",
            ".pytest_cache/",
            ".ruff_cache/",
            ".coverage",
            "htmlcov/",
            ".tox/",
            ".nox/",
            ".hypothesis/",
            "*.mo",
            "*.pot",
            ".venv/",
            "venv/",
            "ENV/",
            ".pytype/",
            "cython_debug/",
        ],
    },

    # Go
    "go": {
        "lock_files": [
            "go.sum",
        ],
        "generated": [
            "vendor/",
            "*.exe",
            "*.exe~",
            "*.dll",
            "*.dylib",
            "*.test",
            "*.out",
            "_obj/",
            "_test/",
            "*.cgo1.go",
            "*.cgo2.c",
            "_cgo_defun.c",
            "_cgo_gotypes.go",
            "_cgo_export.*",
            "_testmain.go",
            "go.work.sum",
        ],
        "proto_generated": [
            "*.pb.go",
            "*_grpc.pb.go",
        ],
    },

    # Rust
    "rust": {
        "lock_files": [
            "Cargo.lock",
        ],
        "generated": [
            "target/",
            "**/*.rs.bk",
            "*.rlib",
            "*.rmeta",
            "*.d",
        ],
    },

    # C/C++
    "cpp": {
        "lock_files": [
            "conan.lock",
            "vcpkg.json.lock",
        ],
        "generated": [
            "*.o",
            "*.obj",
            "*.a",
            "*.lib",
            "*.so",
            "*.dylib",
            "*.dll",
            "*.exe",
            "*.out",
            "*.gch",
            "*.pch",
            "*.d",
            "build/",
            "cmake-build-*/",
            "CMakeCache.txt",
            "CMakeFiles/",
            "cmake_install.cmake",
            "compile_commands.json",
            "Makefile.in",
            "*.mod",
            "*.smod",
            ".deps/",
            ".dirstamp",
            "autom4te.cache/",
            "aclocal.m4",
            "config.h.in",
            "configure",
            "*.lo",
            "*.la",
            ".libs/",
            "libtool",
        ],
    },

    # Common/General
    "common": {
        "generated": [
            ".git/",
            ".svn/",
            ".hg/",
            ".DS_Store",
            "Thumbs.db",
            "*.log",
            "*.bak",
            "*.swp",
            "*.swo",
            "*~",
            ".idea/",
            ".vscode/settings.json",
            "*.min.js",
            "*.min.css",
            "*.map",
            ".terraform/",
            ".terraform.lock.hcl",
        ],
    },
}

# Patterns that indicate auto-generated content in file headers
GENERATED_HEADER_PATTERNS = [
    r"DO NOT EDIT",
    r"DO NOT MODIFY",
    r"AUTO[ -]?GENERATED",
    r"AUTOMATICALLY GENERATED",
    r"THIS FILE IS GENERATED",
    r"Generated by",
    r"@generated",
    r"Code generated .* DO NOT EDIT",
    r"This file was autogenerated",
]


def matches_pattern(file_path, pattern):
    """Check if file path matches a pattern (supports glob-like matching)"""
    file_name = os.path.basename(file_path)

    # Exact match
    if file_name == pattern or file_path.endswith(pattern):
        return True

    # Directory match (pattern ends with /)
    if pattern.endswith("/"):
        dir_name = pattern.rstrip("/")
        if f"/{dir_name}/" in file_path or file_path.startswith(f"{dir_name}/"):
            return True
        # Check if any path component matches
        path_parts = file_path.replace("\\", "/").split("/")
        if dir_name in path_parts:
            return True

    # Wildcard match (*.ext)
    if pattern.startswith("*."):
        ext = pattern[1:]  # includes the dot
        if file_path.endswith(ext):
            return True

    # Double wildcard (**/pattern)
    if pattern.startswith("**/"):
        sub_pattern = pattern[3:]
        if file_path.endswith(sub_pattern) or f"/{sub_pattern}" in file_path:
            return True

    return False


def get_blocked_reason(file_path):
    """Check if file is in the dangerous files list and return reason"""
    for ecosystem, categories in DANGEROUS_FILES.items():
        for category, patterns in categories.items():
            for pattern in patterns:
                if matches_pattern(file_path, pattern):
                    category_name = category.replace("_", " ").title()
                    return f"{ecosystem.upper()} {category_name}: {pattern}"
    return None


def check_file_content_for_generated_marker(file_path):
    """Check if existing file has auto-generated markers in header"""
    if not os.path.exists(file_path):
        return None

    try:
        with open(file_path, "r", encoding="utf-8", errors="ignore") as f:
            # Read first 20 lines or 2KB, whichever comes first
            header = ""
            for i, line in enumerate(f):
                if i >= 20 or len(header) > 2048:
                    break
                header += line

        for pattern in GENERATED_HEADER_PATTERNS:
            if re.search(pattern, header, re.IGNORECASE):
                return pattern
    except (IOError, OSError):
        pass

    return None


def main():
    tool_use = json.loads(sys.stdin.read())
    tool_name = tool_use.get("tool_name", "")
    tool_input = tool_use.get("tool_input", {})

    if tool_name not in ["Write", "Edit", "MultiEdit"]:
        sys.exit(0)

    file_path = tool_input.get("file_path", "")
    if not file_path:
        sys.exit(0)

    # Normalize path
    file_path = file_path.replace("\\", "/")

    # Check against known dangerous files
    blocked_reason = get_blocked_reason(file_path)
    if blocked_reason:
        print(f"❌ Editing this file is blocked!", file=sys.stderr)
        print(f"   File: {file_path}", file=sys.stderr)
        print(f"   Reason: {blocked_reason}", file=sys.stderr)
        print(f"   This file is auto-generated or managed by tools.", file=sys.stderr)
        sys.exit(2)

    # Check file content for generated markers
    generated_marker = check_file_content_for_generated_marker(file_path)
    if generated_marker:
        print(f"❌ Editing this file is blocked!", file=sys.stderr)
        print(f"   File: {file_path}", file=sys.stderr)
        print(f"   Reason: File contains auto-generated marker", file=sys.stderr)
        print(f"   Detected: '{generated_marker}'", file=sys.stderr)
        print(f"   This file appears to be auto-generated.", file=sys.stderr)
        sys.exit(2)

    sys.exit(0)


if __name__ == "__main__":
    main()
